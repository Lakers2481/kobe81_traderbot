"""
Prometheus Metrics for Kobe Trading System.

Provides real-time observability through Prometheus-compatible metrics.
Designed for Grafana dashboards and alerting.

Metrics Categories:
1. Counters: Orders, signals, decisions, errors
2. Gauges: Positions, P&L, win rate, data freshness
3. Histograms: Latency, slippage distributions

Usage:
    from trade_logging.prometheus_metrics import (
        ORDERS_SUBMITTED, SIGNALS_GENERATED, inc_order, set_pnl
    )

    # Increment counter
    ORDERS_SUBMITTED.labels(symbol="AAPL", side="long", strategy="ibs_rsi").inc()

    # Set gauge
    DAILY_PNL.set(150.50)

    # Record histogram
    SLIPPAGE_BPS.observe(5.2)

    # Use helper functions
    inc_order("AAPL", "long", "ibs_rsi")
    set_pnl(daily=150.50, total=1250.00)

Endpoint: /metrics/prometheus (served by monitor/health_endpoints.py)
"""

from __future__ import annotations

import logging
import time
from typing import Optional

logger = logging.getLogger(__name__)

# Try to import prometheus_client
try:
    from prometheus_client import (
        Counter,
        Gauge,
        Histogram,
        CollectorRegistry,
        generate_latest,
        CONTENT_TYPE_LATEST,
    )
    PROMETHEUS_AVAILABLE = True
except ImportError:
    PROMETHEUS_AVAILABLE = False
    logger.warning(
        "prometheus_client not installed. Metrics will be no-op. "
        "Install with: pip install prometheus-client"
    )


# ============================================================================
# Registry
# ============================================================================

# Create isolated registry (not the default global one)
if PROMETHEUS_AVAILABLE:
    REGISTRY = CollectorRegistry()
else:
    REGISTRY = None


# ============================================================================
# Counter Definitions
# ============================================================================

if PROMETHEUS_AVAILABLE:
    ORDERS_SUBMITTED = Counter(
        'kobe_orders_submitted_total',
        'Total orders submitted to broker',
        ['symbol', 'side', 'strategy'],
        registry=REGISTRY
    )

    ORDERS_FILLED = Counter(
        'kobe_orders_filled_total',
        'Total orders successfully filled',
        ['symbol', 'side', 'strategy'],
        registry=REGISTRY
    )

    ORDERS_REJECTED = Counter(
        'kobe_orders_rejected_total',
        'Total orders rejected',
        ['symbol', 'reason'],
        registry=REGISTRY
    )

    ORDERS_CANCELLED = Counter(
        'kobe_orders_cancelled_total',
        'Total orders cancelled',
        ['symbol', 'reason'],
        registry=REGISTRY
    )

    SIGNALS_GENERATED = Counter(
        'kobe_signals_generated_total',
        'Total signals generated by scanner',
        ['strategy'],
        registry=REGISTRY
    )

    SIGNALS_FILTERED = Counter(
        'kobe_signals_filtered_total',
        'Signals filtered out by quality gate',
        ['reason'],
        registry=REGISTRY
    )

    DECISIONS_RECORDED = Counter(
        'kobe_decisions_total',
        'Total decisions recorded',
        ['type'],  # entry, exit, skip
        registry=REGISTRY
    )

    ERRORS_TOTAL = Counter(
        'kobe_errors_total',
        'Total errors encountered',
        ['component', 'type'],
        registry=REGISTRY
    )

    SCANS_COMPLETED = Counter(
        'kobe_scans_completed_total',
        'Total scan runs completed',
        ['mode'],  # normal, preview, weekend
        registry=REGISTRY
    )

    # SECURITY FIX (2026-01-04): Counters for policy/compliance/killswitch rejections
    POLICY_GATE_REJECTED = Counter(
        'kobe_policy_gate_rejected_total',
        'Orders blocked by PolicyGate',
        ['reason'],
        registry=REGISTRY
    )

    COMPLIANCE_REJECTED = Counter(
        'kobe_compliance_rejected_total',
        'Orders blocked by compliance checks',
        ['reason'],
        registry=REGISTRY
    )

    KILL_SWITCH_BLOCKS = Counter(
        'kobe_kill_switch_blocks_total',
        'Operations blocked by kill switch',
        registry=REGISTRY
    )

    # FIX (2026-01-04): Counter for intraday trigger skips
    INTRADAY_TRIGGER_SKIPPED = Counter(
        'kobe_intraday_trigger_skipped_total',
        'Intraday triggers skipped due to missing data or credentials',
        ['reason'],
        registry=REGISTRY
    )

else:
    # No-op placeholders
    class NoOpMetric:
        def labels(self, *args, **kwargs):
            return self
        def inc(self, amount=1):
            pass
        def dec(self, amount=1):
            pass
        def set(self, value):
            pass
        def observe(self, value):
            pass

    ORDERS_SUBMITTED = NoOpMetric()
    ORDERS_FILLED = NoOpMetric()
    ORDERS_REJECTED = NoOpMetric()
    ORDERS_CANCELLED = NoOpMetric()
    SIGNALS_GENERATED = NoOpMetric()
    SIGNALS_FILTERED = NoOpMetric()
    DECISIONS_RECORDED = NoOpMetric()
    ERRORS_TOTAL = NoOpMetric()
    SCANS_COMPLETED = NoOpMetric()
    POLICY_GATE_REJECTED = NoOpMetric()
    COMPLIANCE_REJECTED = NoOpMetric()
    KILL_SWITCH_BLOCKS = NoOpMetric()
    INTRADAY_TRIGGER_SKIPPED = NoOpMetric()


# ============================================================================
# Gauge Definitions
# ============================================================================

if PROMETHEUS_AVAILABLE:
    SYSTEM_UPTIME = Gauge(
        'kobe_uptime_seconds',
        'System uptime in seconds',
        registry=REGISTRY
    )

    OPEN_POSITIONS = Gauge(
        'kobe_open_positions',
        'Current number of open positions',
        registry=REGISTRY
    )

    DAILY_PNL = Gauge(
        'kobe_daily_pnl_usd',
        'Daily P&L in USD',
        registry=REGISTRY
    )

    TOTAL_PNL = Gauge(
        'kobe_total_pnl_usd',
        'Total cumulative P&L in USD',
        registry=REGISTRY
    )

    WIN_RATE = Gauge(
        'kobe_win_rate',
        'Current win rate (0-1)',
        registry=REGISTRY
    )

    PROFIT_FACTOR = Gauge(
        'kobe_profit_factor',
        'Current profit factor',
        registry=REGISTRY
    )

    SHARPE_RATIO = Gauge(
        'kobe_sharpe_ratio',
        'Current Sharpe ratio',
        registry=REGISTRY
    )

    DATA_FRESHNESS = Gauge(
        'kobe_data_freshness_seconds',
        'Age of latest market data in seconds',
        ['symbol'],
        registry=REGISTRY
    )

    LAST_SCAN_TIMESTAMP = Gauge(
        'kobe_last_scan_timestamp',
        'Unix timestamp of last scan',
        registry=REGISTRY
    )

    LAST_TRADE_TIMESTAMP = Gauge(
        'kobe_last_trade_timestamp',
        'Unix timestamp of last trade',
        registry=REGISTRY
    )

    PORTFOLIO_VALUE = Gauge(
        'kobe_portfolio_value_usd',
        'Current portfolio value in USD',
        registry=REGISTRY
    )

    BUYING_POWER = Gauge(
        'kobe_buying_power_usd',
        'Available buying power in USD',
        registry=REGISTRY
    )

    VIX_LEVEL = Gauge(
        'kobe_vix_level',
        'Current VIX level',
        registry=REGISTRY
    )

    QUALITY_GATE_SCORE = Gauge(
        'kobe_quality_gate_score',
        'Latest quality gate score',
        ['symbol'],
        registry=REGISTRY
    )

    ADJUDICATION_SCORE = Gauge(
        'kobe_adjudication_score',
        'Latest adjudication score',
        ['symbol'],
        registry=REGISTRY
    )

else:
    SYSTEM_UPTIME = NoOpMetric()
    OPEN_POSITIONS = NoOpMetric()
    DAILY_PNL = NoOpMetric()
    TOTAL_PNL = NoOpMetric()
    WIN_RATE = NoOpMetric()
    PROFIT_FACTOR = NoOpMetric()
    SHARPE_RATIO = NoOpMetric()
    DATA_FRESHNESS = NoOpMetric()
    LAST_SCAN_TIMESTAMP = NoOpMetric()
    LAST_TRADE_TIMESTAMP = NoOpMetric()
    PORTFOLIO_VALUE = NoOpMetric()
    BUYING_POWER = NoOpMetric()
    VIX_LEVEL = NoOpMetric()
    QUALITY_GATE_SCORE = NoOpMetric()
    ADJUDICATION_SCORE = NoOpMetric()


# ============================================================================
# Histogram Definitions
# ============================================================================

if PROMETHEUS_AVAILABLE:
    ORDER_LATENCY = Histogram(
        'kobe_order_latency_seconds',
        'Order submission to fill latency',
        buckets=[0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0, 30.0],
        registry=REGISTRY
    )

    SLIPPAGE_BPS = Histogram(
        'kobe_slippage_bps',
        'Order slippage in basis points',
        buckets=[0, 2, 5, 10, 25, 50, 100, 250],
        registry=REGISTRY
    )

    SCAN_DURATION = Histogram(
        'kobe_scan_duration_seconds',
        'Duration of scan runs',
        buckets=[1, 5, 10, 30, 60, 120, 300],
        registry=REGISTRY
    )

    SIGNAL_SCORE = Histogram(
        'kobe_signal_score',
        'Distribution of signal quality scores',
        buckets=[0, 20, 40, 60, 70, 80, 90, 100],
        registry=REGISTRY
    )

else:
    ORDER_LATENCY = NoOpMetric()
    SLIPPAGE_BPS = NoOpMetric()
    SCAN_DURATION = NoOpMetric()
    SIGNAL_SCORE = NoOpMetric()


# ============================================================================
# Helper Functions
# ============================================================================

def inc_order(symbol: str, side: str, strategy: str, filled: bool = False) -> None:
    """Increment order counters."""
    ORDERS_SUBMITTED.labels(symbol=symbol, side=side, strategy=strategy).inc()
    if filled:
        ORDERS_FILLED.labels(symbol=symbol, side=side, strategy=strategy).inc()


def inc_order_rejected(symbol: str, reason: str) -> None:
    """Increment order rejection counter."""
    ORDERS_REJECTED.labels(symbol=symbol, reason=reason).inc()


def inc_signal(strategy: str, count: int = 1) -> None:
    """Increment signal counter."""
    for _ in range(count):
        SIGNALS_GENERATED.labels(strategy=strategy).inc()


def inc_decision(decision_type: str) -> None:
    """Increment decision counter."""
    DECISIONS_RECORDED.labels(type=decision_type).inc()


def inc_error(component: str, error_type: str) -> None:
    """Increment error counter."""
    ERRORS_TOTAL.labels(component=component, type=error_type).inc()


def inc_scan(mode: str = "normal") -> None:
    """Increment scan counter."""
    SCANS_COMPLETED.labels(mode=mode).inc()


def set_pnl(daily: Optional[float] = None, total: Optional[float] = None) -> None:
    """Set P&L gauges."""
    if daily is not None:
        DAILY_PNL.set(daily)
    if total is not None:
        TOTAL_PNL.set(total)


def set_performance(
    win_rate: Optional[float] = None,
    profit_factor: Optional[float] = None,
    sharpe: Optional[float] = None,
) -> None:
    """Set performance gauges."""
    if win_rate is not None:
        WIN_RATE.set(win_rate)
    if profit_factor is not None:
        PROFIT_FACTOR.set(profit_factor)
    if sharpe is not None:
        SHARPE_RATIO.set(sharpe)


def set_portfolio(
    value: Optional[float] = None,
    buying_power: Optional[float] = None,
    positions: Optional[int] = None,
) -> None:
    """Set portfolio gauges."""
    if value is not None:
        PORTFOLIO_VALUE.set(value)
    if buying_power is not None:
        BUYING_POWER.set(buying_power)
    if positions is not None:
        OPEN_POSITIONS.set(positions)


def set_data_freshness(symbol: str, age_seconds: float) -> None:
    """Set data freshness for a symbol."""
    DATA_FRESHNESS.labels(symbol=symbol).set(age_seconds)


def record_scan_completed(duration_seconds: float, mode: str = "normal") -> None:
    """Record scan completion with duration."""
    SCAN_DURATION.observe(duration_seconds)
    SCANS_COMPLETED.labels(mode=mode).inc()
    LAST_SCAN_TIMESTAMP.set(time.time())


def record_trade_completed(
    slippage_bps: float,
    latency_seconds: Optional[float] = None,
) -> None:
    """Record trade execution metrics."""
    SLIPPAGE_BPS.observe(slippage_bps)
    if latency_seconds is not None:
        ORDER_LATENCY.observe(latency_seconds)
    LAST_TRADE_TIMESTAMP.set(time.time())


def record_signal_score(score: float) -> None:
    """Record signal quality score."""
    SIGNAL_SCORE.observe(score)


def set_uptime(start_time: float) -> None:
    """Set uptime based on start timestamp."""
    SYSTEM_UPTIME.set(time.time() - start_time)


def set_vix(level: float) -> None:
    """Set current VIX level."""
    VIX_LEVEL.set(level)


# ============================================================================
# Export Function
# ============================================================================

def get_metrics_text() -> bytes:
    """
    Get Prometheus-formatted metrics text.

    Returns:
        Bytes containing Prometheus text format metrics
    """
    if not PROMETHEUS_AVAILABLE:
        return b"# prometheus_client not installed\n"

    return generate_latest(REGISTRY)


def get_content_type() -> str:
    """Get content type for Prometheus response."""
    if not PROMETHEUS_AVAILABLE:
        return "text/plain; charset=utf-8"
    return CONTENT_TYPE_LATEST
