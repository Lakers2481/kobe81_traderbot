"""
Circuit Breaker Manager - Orchestrates All Protection Systems

The BreakerManager checks all circuit breakers before every trade decision
and returns the appropriate action: CONTINUE, REDUCE_SIZE, PAUSE_NEW, or HALT_ALL.

Solo Trader Features:
- Automatic position reduction before full halt
- Telegram alerts when any breaker triggers
- Gradual re-entry after breaker clears
- Daily breaker status in dashboard

Author: Kobe Trading System
Created: 2026-01-04
"""

import json
from dataclasses import dataclass, field, asdict
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Optional, List, Dict, Any

from core.structured_log import get_logger

logger = get_logger(__name__)


class BreakerAction(Enum):
    """Actions that circuit breakers can take."""
    CONTINUE = "continue"           # All clear - trade normally
    REDUCE_SIZE = "reduce_size"     # Cut position sizes by 50%
    PAUSE_NEW = "pause_new"         # No new trades, manage existing only
    HALT_ALL = "halt_all"           # Flatten all positions and stop
    ALERT_ONLY = "alert_only"       # Alert but don't stop trading


class BreakerStatus(Enum):
    """Status of individual circuit breaker."""
    GREEN = "green"     # Normal - no concerns
    YELLOW = "yellow"   # Caution - approaching threshold
    RED = "red"         # Triggered - action required


@dataclass
class BreakerAlert:
    """Alert generated by a circuit breaker."""
    breaker_name: str
    status: BreakerStatus
    action: BreakerAction
    message: str
    threshold: float
    current_value: float
    timestamp: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "breaker_name": self.breaker_name,
            "status": self.status.value,
            "action": self.action.value,
            "message": self.message,
            "threshold": self.threshold,
            "current_value": self.current_value,
            "timestamp": self.timestamp.isoformat(),
        }


@dataclass
class BreakerState:
    """Current state of all circuit breakers."""
    overall_action: BreakerAction
    overall_status: BreakerStatus
    size_multiplier: float  # 1.0 = full size, 0.5 = half size, 0 = no trades
    alerts: List[BreakerAlert]
    last_check: datetime
    breaker_details: Dict[str, Dict[str, Any]]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "overall_action": self.overall_action.value,
            "overall_status": self.overall_status.value,
            "size_multiplier": self.size_multiplier,
            "alerts": [a.to_dict() for a in self.alerts],
            "last_check": self.last_check.isoformat(),
            "breaker_details": self.breaker_details,
        }


class BreakerManager:
    """
    Orchestrates all circuit breakers and determines trading action.

    Hierarchy (highest priority first):
    1. HALT_ALL - Any breaker can trigger this
    2. PAUSE_NEW - No new trades
    3. REDUCE_SIZE - Cut sizes by 50%
    4. ALERT_ONLY - Warning only
    5. CONTINUE - All clear

    Features:
    - Automatic cooldown after breaker clears
    - Gradual re-entry (don't go 0% â†’ 100% instantly)
    - State persistence across restarts
    - Telegram integration for alerts
    """

    STATE_FILE = Path("state/circuit_breakers/breaker_state.json")
    ALERT_LOG = Path("state/circuit_breakers/alerts.jsonl")

    # Cooldown after breaker clears before returning to full size
    COOLDOWN_MINUTES = 30

    # Gradual re-entry steps
    REENTRY_STEPS = [0.25, 0.50, 0.75, 1.0]
    REENTRY_INTERVAL_MINUTES = 15

    def __init__(self):
        """Initialize breaker manager with all sub-breakers."""
        self.breakers: Dict[str, Any] = {}
        self._state: Optional[BreakerState] = None
        self._last_alert_time: Dict[str, datetime] = {}
        self._cooldown_start: Optional[datetime] = None
        self._reentry_step: int = 0

        # Ensure state directory exists
        self.STATE_FILE.parent.mkdir(parents=True, exist_ok=True)

        # Load persisted state
        self._load_state()

        # Initialize breakers (lazy - only when first needed)
        self._breakers_initialized = False

    def _init_breakers(self) -> None:
        """Initialize all sub-breakers (lazy loading)."""
        if self._breakers_initialized:
            return

        try:
            from .drawdown_breaker import DrawdownBreaker
            from .volatility_breaker import VolatilityBreaker
            from .streak_breaker import StreakBreaker
            from .correlation_breaker import CorrelationBreaker
            from .execution_breaker import ExecutionBreaker

            self.breakers = {
                "drawdown": DrawdownBreaker(),
                "volatility": VolatilityBreaker(),
                "streak": StreakBreaker(),
                "correlation": CorrelationBreaker(),
                "execution": ExecutionBreaker(),
            }
            self._breakers_initialized = True
            logger.info(f"Initialized {len(self.breakers)} circuit breakers")

        except Exception as e:
            logger.error(f"Failed to initialize breakers: {e}")
            self.breakers = {}

    def _load_state(self) -> None:
        """Load persisted state from file."""
        if self.STATE_FILE.exists():
            try:
                with open(self.STATE_FILE, "r") as f:
                    data = json.load(f)

                self._cooldown_start = (
                    datetime.fromisoformat(data["cooldown_start"])
                    if data.get("cooldown_start")
                    else None
                )
                self._reentry_step = data.get("reentry_step", 0)
                logger.debug("Loaded circuit breaker state")

            except Exception as e:
                logger.warning(f"Failed to load breaker state: {e}")

    def _save_state(self, state: BreakerState) -> None:
        """Persist state to file."""
        try:
            data = {
                "cooldown_start": (
                    self._cooldown_start.isoformat()
                    if self._cooldown_start
                    else None
                ),
                "reentry_step": self._reentry_step,
                "last_state": state.to_dict(),
            }

            with open(self.STATE_FILE, "w") as f:
                json.dump(data, f, indent=2)

        except Exception as e:
            logger.error(f"Failed to save breaker state: {e}")

    def _log_alert(self, alert: BreakerAlert) -> None:
        """Append alert to log file."""
        try:
            with open(self.ALERT_LOG, "a") as f:
                f.write(json.dumps(alert.to_dict()) + "\n")
        except Exception as e:
            logger.error(f"Failed to log alert: {e}")

    def _should_send_alert(self, breaker_name: str, status: BreakerStatus) -> bool:
        """Check if we should send alert (avoid spam)."""
        # Only alert on YELLOW or RED
        if status == BreakerStatus.GREEN:
            return False

        # Rate limit: max once per 5 minutes per breaker
        last_time = self._last_alert_time.get(breaker_name)
        if last_time and (datetime.now() - last_time) < timedelta(minutes=5):
            return False

        return True

    def _send_telegram_alert(self, alert: BreakerAlert) -> None:
        """Send alert to Telegram."""
        try:
            from alerts.telegram_alerts import send_alert

            emoji = "âš ï¸" if alert.status == BreakerStatus.YELLOW else "ðŸš¨"

            message = (
                f"{emoji} **CIRCUIT BREAKER ALERT**\n\n"
                f"**Breaker:** {alert.breaker_name}\n"
                f"**Status:** {alert.status.value.upper()}\n"
                f"**Action:** {alert.action.value}\n"
                f"**Message:** {alert.message}\n"
                f"**Value:** {alert.current_value:.2%} (threshold: {alert.threshold:.2%})"
            )

            send_alert(message, level="warning" if alert.status == BreakerStatus.YELLOW else "critical")
            self._last_alert_time[alert.breaker_name] = datetime.now()

        except ImportError:
            logger.debug("Telegram alerts not available")
        except Exception as e:
            logger.warning(f"Failed to send Telegram alert: {e}")

    def _calculate_size_multiplier(self, action: BreakerAction) -> float:
        """Calculate position size multiplier based on action and re-entry state."""
        if action == BreakerAction.HALT_ALL:
            return 0.0
        elif action == BreakerAction.PAUSE_NEW:
            return 0.0  # No new positions
        elif action == BreakerAction.REDUCE_SIZE:
            return 0.5

        # Check if we're in cooldown/re-entry
        if self._cooldown_start:
            elapsed = (datetime.now() - self._cooldown_start).total_seconds() / 60

            # Calculate which re-entry step we're on
            step_index = min(
                int(elapsed / self.REENTRY_INTERVAL_MINUTES),
                len(self.REENTRY_STEPS) - 1
            )

            if step_index >= len(self.REENTRY_STEPS) - 1:
                # Cooldown complete
                self._cooldown_start = None
                self._reentry_step = 0
                return 1.0

            self._reentry_step = step_index
            return self.REENTRY_STEPS[step_index]

        return 1.0

    def check(
        self,
        equity: float,
        peak_equity: float,
        daily_pnl: float,
        weekly_pnl: float,
        recent_trades: Optional[List[Dict]] = None,
        vix_level: Optional[float] = None,
        avg_slippage_bps: Optional[float] = None,
    ) -> BreakerState:
        """
        Check all circuit breakers and return overall state.

        Args:
            equity: Current account equity
            peak_equity: Peak equity (for drawdown calculation)
            daily_pnl: Today's P&L as fraction of equity
            weekly_pnl: This week's P&L as fraction of equity
            recent_trades: List of recent trades for streak analysis
            vix_level: Current VIX level (optional)
            avg_slippage_bps: Recent average slippage in basis points (optional)

        Returns:
            BreakerState with overall action and all alerts
        """
        self._init_breakers()

        alerts: List[BreakerAlert] = []
        breaker_details: Dict[str, Dict[str, Any]] = {}

        # Default to CONTINUE
        overall_action = BreakerAction.CONTINUE
        overall_status = BreakerStatus.GREEN

        # Check each breaker
        for name, breaker in self.breakers.items():
            try:
                # Build kwargs based on what each breaker needs
                kwargs = {
                    "equity": equity,
                    "peak_equity": peak_equity,
                    "daily_pnl": daily_pnl,
                    "weekly_pnl": weekly_pnl,
                }

                if name == "streak" and recent_trades is not None:
                    kwargs["recent_trades"] = recent_trades
                elif name == "volatility" and vix_level is not None:
                    kwargs["vix_level"] = vix_level
                elif name == "execution" and avg_slippage_bps is not None:
                    kwargs["avg_slippage_bps"] = avg_slippage_bps

                # Check breaker
                result = breaker.check(**kwargs)

                breaker_details[name] = {
                    "status": result["status"].value,
                    "action": result["action"].value,
                    "message": result.get("message", ""),
                    "current_value": result.get("current_value"),
                    "threshold": result.get("threshold"),
                }

                # Create alert if needed
                if result["status"] != BreakerStatus.GREEN:
                    alert = BreakerAlert(
                        breaker_name=name,
                        status=result["status"],
                        action=result["action"],
                        message=result.get("message", f"{name} triggered"),
                        threshold=result.get("threshold", 0),
                        current_value=result.get("current_value", 0),
                    )
                    alerts.append(alert)
                    self._log_alert(alert)

                    # Send Telegram if appropriate
                    if self._should_send_alert(name, result["status"]):
                        self._send_telegram_alert(alert)

                # Update overall status (highest severity wins)
                if result["status"] == BreakerStatus.RED:
                    overall_status = BreakerStatus.RED
                elif result["status"] == BreakerStatus.YELLOW and overall_status != BreakerStatus.RED:
                    overall_status = BreakerStatus.YELLOW

                # Update overall action (most restrictive wins)
                action_priority = {
                    BreakerAction.HALT_ALL: 4,
                    BreakerAction.PAUSE_NEW: 3,
                    BreakerAction.REDUCE_SIZE: 2,
                    BreakerAction.ALERT_ONLY: 1,
                    BreakerAction.CONTINUE: 0,
                }

                if action_priority[result["action"]] > action_priority[overall_action]:
                    overall_action = result["action"]

            except Exception as e:
                logger.error(f"Error checking {name} breaker: {e}")
                breaker_details[name] = {
                    "status": "error",
                    "error": str(e),
                }

        # Handle cooldown transition
        if overall_action == BreakerAction.CONTINUE and self._state:
            if self._state.overall_action in [BreakerAction.HALT_ALL, BreakerAction.PAUSE_NEW]:
                # Breaker just cleared - start cooldown
                if not self._cooldown_start:
                    self._cooldown_start = datetime.now()
                    logger.info("Circuit breaker cleared - starting cooldown re-entry")
        elif overall_action in [BreakerAction.HALT_ALL, BreakerAction.PAUSE_NEW]:
            # Breaker triggered - reset cooldown
            self._cooldown_start = None
            self._reentry_step = 0

        # Calculate size multiplier
        size_multiplier = self._calculate_size_multiplier(overall_action)

        # Build state
        state = BreakerState(
            overall_action=overall_action,
            overall_status=overall_status,
            size_multiplier=size_multiplier,
            alerts=alerts,
            last_check=datetime.now(),
            breaker_details=breaker_details,
        )

        self._state = state
        self._save_state(state)

        # Log if not green
        if overall_status != BreakerStatus.GREEN:
            logger.warning(
                f"Circuit breaker status: {overall_status.value} | "
                f"Action: {overall_action.value} | "
                f"Size multiplier: {size_multiplier:.0%}"
            )

        return state

    def get_current_state(self) -> Optional[BreakerState]:
        """Get the last checked state."""
        return self._state

    def get_status_summary(self) -> Dict[str, Any]:
        """Get summary for dashboard display."""
        if not self._state:
            return {
                "status": "unknown",
                "action": "unknown",
                "size_multiplier": 1.0,
                "message": "No recent check",
                "breakers": {},
            }

        return {
            "status": self._state.overall_status.value,
            "action": self._state.overall_action.value,
            "size_multiplier": self._state.size_multiplier,
            "last_check": self._state.last_check.isoformat(),
            "alerts_count": len(self._state.alerts),
            "breakers": self._state.breaker_details,
            "in_cooldown": self._cooldown_start is not None,
            "reentry_step": self._reentry_step,
        }

    def force_halt(self, reason: str) -> None:
        """Manually trigger HALT_ALL (emergency use)."""
        alert = BreakerAlert(
            breaker_name="manual",
            status=BreakerStatus.RED,
            action=BreakerAction.HALT_ALL,
            message=f"Manual halt: {reason}",
            threshold=0,
            current_value=0,
        )

        self._state = BreakerState(
            overall_action=BreakerAction.HALT_ALL,
            overall_status=BreakerStatus.RED,
            size_multiplier=0.0,
            alerts=[alert],
            last_check=datetime.now(),
            breaker_details={"manual": {"status": "red", "reason": reason}},
        )

        self._save_state(self._state)
        self._log_alert(alert)
        self._send_telegram_alert(alert)

        logger.critical(f"MANUAL HALT triggered: {reason}")

    def clear_halt(self) -> None:
        """Clear manual halt and start cooldown."""
        self._cooldown_start = datetime.now()
        self._reentry_step = 0
        logger.info("Manual halt cleared - starting cooldown re-entry")


# Singleton instance
_manager: Optional[BreakerManager] = None


def get_breaker_manager() -> BreakerManager:
    """Get or create singleton breaker manager."""
    global _manager
    if _manager is None:
        _manager = BreakerManager()
    return _manager


def check_all_breakers(**kwargs) -> BreakerState:
    """Convenience function to check all breakers."""
    return get_breaker_manager().check(**kwargs)


def get_breaker_status() -> Dict[str, Any]:
    """Convenience function to get status summary."""
    return get_breaker_manager().get_status_summary()


if __name__ == "__main__":
    # Demo
    manager = BreakerManager()

    print("=== Circuit Breaker Manager Demo ===\n")

    # Simulate check
    state = manager.check(
        equity=50000,
        peak_equity=55000,
        daily_pnl=-0.015,  # Down 1.5% today
        weekly_pnl=-0.03,  # Down 3% this week
        vix_level=22,
    )

    print(f"Overall Status: {state.overall_status.value}")
    print(f"Overall Action: {state.overall_action.value}")
    print(f"Size Multiplier: {state.size_multiplier:.0%}")
    print(f"\nBreaker Details:")
    for name, details in state.breaker_details.items():
        print(f"  {name}: {details}")

    if state.alerts:
        print(f"\nAlerts ({len(state.alerts)}):")
        for alert in state.alerts:
            print(f"  - {alert.breaker_name}: {alert.message}")
